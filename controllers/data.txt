export const getSinglePath = async (req, res) => {
  try {
    const userId = req.user?.userId;
    const pathId = req.params.id;

    if (!userId) {
      return res
        .status(400)
        .json(
          failureResponse(
            { error: "User ID is required" },
            "Failed to get details"
          )
        );
    }
    if (!pathId) {
      return res
        .status(400)
        .json(
          failureResponse(
            { error: "Path ID is required" },
            "Failed to get details"
          )
        );
    }

    // Fetch the main path
    const pathQuery =
      "SELECT id, status FROM path WHERE user_id = ? AND id = ? AND status = 'analyzed'";
    const pathResult = await query(pathQuery, [userId, pathId]);

    if (pathResult.length === 0) {
      return res
        .status(404)
        .json(
          failureResponse({ status: false }, "No paths found for this user.")
        );
    }

    const path = pathResult[0];

    // Fetch branches and steps for the path
    const branchesQuery =
      "SELECT id, color, step_id FROM branch WHERE path_id = ?";
    const branchesResult = await query(branchesQuery, [pathId]);

    const stepsQuery =
      "SELECT id, title, description, branch_id FROM steps WHERE path_id = ?";
    const stepsResult = await query(stepsQuery, [pathId]);

    const stepIds = stepsResult.map((step) => step.id);

    // Fetch skills only if there are steps
    let skillsResult = [];
    if (stepIds.length > 0) {
      const skillsQuery =
        "SELECT title, step_id FROM skills WHERE step_id IN (?)";
      skillsResult = await query(skillsQuery, [stepIds]);
    }

    // Function to find branches by step_id
    const findBranchByStepId = (branches, step_id) => {
      return branches.find((branch) => branch.step_id === step_id);
    };

    // Recursive function to process steps
    const processSteps = async (branch, branches, steps) => {
      const processedSteps = [];

      for (const step of steps) {
        if (step.branch_id === branch.id) {
          // Fetch skills for the step
          const stepSkills = skillsResult.filter(
            (skill) => skill.step_id === step.id
          );
          const stepWithSkills = {
            title: step.title,
            description: step.description,
            skills: stepSkills.map((skill) => ({ title: skill.title })),
          };

          const subBranch = findBranchByStepId(branches, step.id);
          if (subBranch) {
            // Process the sub-branch
            const processedSubBranch = await processSteps(
              subBranch,
              branches,
              steps
            );
            processedSteps.push({
              ...stepWithSkills,
              ...processedSubBranch,
            });
          } else {
            processedSteps.push(stepWithSkills);
          }
        }
      }

      // Include only color in the branch object, remove id
      const { color } = branch;
      return { color, steps: processedSteps };
    };

    // Convert branches to an object with branch details but no IDs
    const branchesObject = {};
    for (const branch of branchesResult) {
      const processedBranch = await processSteps(
        branch,
        branchesResult,
        stepsResult
      );
      branchesObject[branch.id] = processedBranch;
    }

    const result = {
      id: path.id,
      status: path.status,
      branch:
        Object.keys(branchesObject).length > 0
          ? Object.values(branchesObject)
          : {},
    };

    return res
      .status(200)
      .json(successResponse(result, "Path retrieved successfully"));
  } catch (error) {
    console.error("Error fetching path details:", error);
    return res
      .status(500)
      .json(
        failureResponse(
          { error: "Internal Server Error" },
          "Failed to get the data"
        )
      );
  }
};