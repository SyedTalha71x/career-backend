export const sendMessage = async (req, res) => {
  try {
    console.log("Request Received:");

    const { message, step_id } = req.body;
    console.log(message);
    console.log(step_id);

    // Check if step_id is provided
    if (!step_id) {
      return res.status(400).json({
        status: false,
        error: "Step ID is required",
      });
    }

    const uploadedFile = req.file ? req.file.filename : null;
    console.log("File:", uploadedFile);

    const systemMessage =
      "You are an experienced career advisor with a deep understanding of career development paths.";

    // Fetch conversation history
    const getConversationHistory = async (stepId) => {
      const historyQuery = `
        SELECT prompt, result 
        FROM gpt_data 
        WHERE step_id = ? 
        ORDER BY created ASC
      `;
      try {
        const historyRecords = await query(historyQuery, [stepId]);
        console.log(`History records for step_id ${stepId}:`, historyRecords);
        return historyRecords;
      } catch (error) {
        console.error("Error fetching conversation history:", error);
        return [];
      }
    };

    const conversationHistory = await getConversationHistory(step_id);

    // Initialize messages array
    const messages = [{ role: "system", content: systemMessage }];

    // Append valid conversation history
    conversationHistory.forEach((record) => {
      if (record.prompt) {
        messages.push({ role: "user", content: record.prompt });
      }
      if (record.result) {
        messages.push({ role: "assistant", content: record.result });
      }
    });

    // Handle uploaded file
    if (uploadedFile) {
      const filePath = `./uploads/${uploadedFile}`;
      const fileExtension = path.extname(uploadedFile).toLowerCase();

      // Validate file type
      if (fileExtension !== ".pdf") {
        return res.status(400).json({
          status: false,
          error: "Only PDF files are allowed.",
        });
      }

      // Extract text from PDF
      const extractedText = await extractTextFromPDF(filePath);
      if (extractedText) {
        messages.push({
          role: "user",
          content: `User uploaded a PDF file with the following content: \n${extractedText}`,
        });
      } else {
        console.log("No content extracted from PDF file.");
      }
    }

    // Add user's message if provided
    messages.push({
      role: "user",
      content: message || "No specific input provided by the user.",
    });
    console.log("Final cleaned messages array:", JSON.stringify(messages, null, 2));
    const userResponse = await axios.post(
      "https://api.openai.com/v1/chat/completions",
      {
        model: "gpt-4o-mini",
        messages: messages,
        max_tokens: 2000,
      },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.OPENAI_SECRET_KEY}`,
        },
      }
    );

    console.log(userResponse.data);

    const assistantResponse = userResponse.data.choices[0].message.content;

    const previousRecordQuery = `
      SELECT id FROM gpt_data 
      WHERE step_id = ? 
      ORDER BY created DESC 
      LIMIT 1
    `;
    const previousRecord = await query(previousRecordQuery, [step_id]);
    console.log("Previous record:", previousRecord);

    const parentId = previousRecord.length > 0 ? previousRecord[0].id : null;

    // Insert conversation into database
    const insertQuery = `
      INSERT INTO gpt_data (result, step_id, parent_gpt_id, prompt, file) 
      VALUES (?, ?, ?, ?, ?)
    `;
    const queryParams = [
      assistantResponse,
      step_id,
      parentId,
      message || null,
      uploadedFile || null,
    ];
    await query(insertQuery, queryParams);

    // Log full conversation
    const fullConversation = [
      { role: "system", content: systemMessage },
      ...messages.slice(1), // Exclude the initial system message
      { role: "assistant", content: assistantResponse },
    ];
    console.log("Full Conversation:", fullConversation);

    // Return success response
    return res.status(200).json({
      status: true,
      message: assistantResponse,
    });
  } catch (error) {
    console.error("Error in sendMessage API:", error);
    return res.status(500).json({
      status: false,
      error: error.message || "Internal Server Error",
    });
  }
};